Passed Default Tests - 2/2 - 18.5/18.5
Passed Student Tests - 27/35 - 3.5/4.5
Provided Accurate Tests - 2/2 - 1/2
Final Grade - 18.5 + 3.5 + 2 = 24/25

testing right inputs:
testing  ../test/abrouil2-right.inp
int **x, y, z;
float this[1][2][3][4][5], was, testing[arrays];

while(x){
w = y + (v * -123);
}
if(a[45])
 if(lot == of)
   if(nested){
    if(ifs)
     x = -456 * that;
   }
./proj1 < ../test/abrouil2-right.inp
./proj1 < ../test/abrouil2-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token MULT ()
Line 1 : syntax error : * 
make: *** [run] Error 1
FAILED
testing  ../test/alanghar-right.inp
int a, b, __this_is_4_test[234][10];
;
{}{{;}}
if(some_expr == (5>=3)){
    while(a < 54.8 && j > 8 || (x > 0))
        lkj = 234 + jlksdjf[324];

    while(true){
        if(x == y)
            blah;
        else{
            while(false){
                var[4][3][2] = var[3][4];   //This is a comment. 3=5
            }
        }
    }
}
/* this is a *** /// *** ()()()(*&*^%#^%$[][]35)
block comment */./proj1 < ../test/alanghar-right.inp
./proj1 < ../test/alanghar-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token SEMICOLON ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0
Entering state 7
Next token is token SEMICOLON ()
Line 2 : syntax error : ; 
make: *** [run] Error 1
FAILED
testing  ../test/alynn-right.inp
int x, y;
int a, b;
float decarray[40];
decarray[1] = 526.2420;
x = 256;
y = 25;
a = 1;
b = 2;
if(x > y)
a = x * y;
else
b = x + 1;
x = 1;
y = 10;
while(x < y) {
/*Code to test while loop*/
a = a - 1;
x = x + 1;
}
./proj1 < ../test/alynn-right.inp
./proj1 < ../test/alynn-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 13 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 13 13 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 13 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13 13 13 13
Entering state 13
Reading a token: Next token is token IF ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token GT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 1 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 1 18
Entering state 47
Next token is token GT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18
Entering state 46
Next token is token GT ()
Shifting token GT ()
Entering state 74
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 1 18 46 74
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 1 18 46 74
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18 46 74
Entering state 109
Reducing stack by rule 35 (line 84):
   $1 = nterm math ()
   $2 = token GT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 1 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8
Entering state 10
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 10 17 33
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 10 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 10 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 10 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 10 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 10
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 10
Entering state 13
Reading a token: Next token is token ELSE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 10
Entering state 28
Next token is token ELSE ()
Shifting token ELSE ()
Entering state 52
Reducing stack by rule 17 (line 61):
   $1 = token ELSE ()
-> $$ = nterm else ()
Stack now 0 8 10 28
Entering state 53
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 28 53
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 28 53 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 10 28 53 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 10 28 53 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 10 28 53 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 10 28 53 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 10 28 53 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 10 28 53 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 10 28 53
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 10 28 53
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 28 53 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 10 28 53 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 10 28 53 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 10 28 53 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 10 28 53 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 10 28 53 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 28 53 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 10 28 53 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 10 28 53 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 10 28 53 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 10 28 53 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 10 28 53 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 10 28 53 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 10 28 53 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 10 28 53
Entering state 89
Reducing stack by rule 11 (line 53):
   $1 = nterm if ()
   $2 = nterm block ()
   $3 = nterm else ()
   $4 = nterm block ()
-> $$ = nterm conditional ()
Stack now 0 8
Entering state 9
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 9 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 9 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 9 2 18 46 73
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 9 2 18 46 73
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 9 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 9 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 9
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token COMMENT ()
Line 16 : syntax error : /*Code to test while loop*/ 
make: *** [run] Error 1
FAILED
testing  ../test/amoorhou-right.inp
/* This is my first comment at the top*/
int a,b,c,d,e,f;
float a[100][100];
while (a==b){
a=b;
b=a*c;
c=a/f;
d=a+b*c;
c=a*c-e;
if (!(a == b + 1 * (c - 1) / 2)){
	y=1;
	if (a<2){
		a[i]= y+1;
	}
	/* This is my second comment in the middle*/
}
if (b!=f){
	y=1;
}
if (a<=b) a=0.324;
while (x>=5) a=a-1;
/* This is my third comment at the end*/
}

./proj1 < ../test/amoorhou-right.inp
./proj1 < ../test/amoorhou-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token COMMENT ()
Line 1 : syntax error : /* This is my first comment at the top*/ 
make: *** [run] Error 1
FAILED
testing  ../test/bwoodroo-right.inp
int a;
int b;
int c;
float d;
float e;

a = 1;
b = 2;
c = a + b;

d = 1.5;
e = 2.4;

while (d <= e)
{
	c = a + e;
	d = d + 0.5;
}
./proj1 < ../test/bwoodroo-right.inp
./proj1 < ../test/bwoodroo-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13 13 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13 13 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13 13 13
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13 13 13 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13 13 13 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13 13 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 13 13 13 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 13 13 13 13 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13 13 13 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 13 13 13 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 13 13 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 13 13 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 13 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13 13 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 13 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 13 13 13 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 13 13 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 13 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13 13 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13 13 13 13 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13 13 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LE ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18
Entering state 47
Next token is token LE ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18
Entering state 46
Next token is token LE ()
Shifting token LE ()
Entering state 75
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18 46 75
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 46 75
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 46 75
Entering state 110
Reducing stack by rule 34 (line 83):
   $1 = nterm math ()
   $2 = token LE ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 13 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 13 17 33 47
Entering state 83
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 13 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 13 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 13
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8
Entering state 8
Reading a token: Now at end of input.
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0
Entering state 7
Now at end of input.
Shifting token $end ()
Entering state 24
Stack now 0 7 24
Cleanup: popping token $end ()
Cleanup: popping nterm input ()
testing  ../test/chare-right.inp
int x, y, z;
float a, b, c;
float d[100], g[100][50];

!(a == b + 1 * (c - 1) / 2)

{a = b + c; d + a + 2; }

if (a < b) c = b;
else
c = a;

while(a < b) {
a = a + 1;
}
./proj1 < ../test/chare-right.inp
./proj1 < ../test/chare-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 13 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 13 16 32 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 13 13 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 13 16 32 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token NOT ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token NOT ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0
Entering state 7
Next token is token NOT ()
Line 5 : syntax error : ! 
make: *** [run] Error 1
FAILED
testing  ../test/cstone2-right.inp
int a;
int b;
b = 7;
/* hello, this file is grammatically correct!  */
float  f [50][100], g [b];
;;;; /*random semicolons*/
a = 5;
/* hello
world!!!!!!!!!!!!!!!
********************
*******/

a = a + 5 - 2;
float b, c, d , e;
/* some math ---------------- */
b = 2.2 - (9 - 5) * 3 / (a + a) - ( ( b - a) / 5.0 ); 

/*random horribly spaced braces */
{ 
{int a [9]; {}
} int c; c = 7 -7 + (a); a = ( (1+1) + (3+5*2/1)) }


/* ifs and whiles*/
if ( a == 5 )
	c = 7;
if (b <= 7 && c == 1 ||!( b == 2) || 5 != 4 )
{
	a = 6 + 8;
	b = 1/2;
}
else
	6 + 7;

while ( 7 != 6 + 1)
{
	a = a + a;
	7+ 49;
}
while (6 < a)
	a = 5 - a ;

/* crazy nested ifs and while */
if ( !((7 == 7)))
{
	if ( a == b)
	{
		if ( b > c)
		{
			while ( c - 2 > 4 || b != !(c < 3))
			{	int y, z;
		
				if ( b >= 1) { x = 2; c = 7; int q; q = 0;}
			}
		}
	}
}

/* make sure negative numbers work */
float negative_variable;
negative_variable = -10 + a * c;
if (-3 == negative_variable)
	b = -1;
else
	b = a;

./proj1 < ../test/cstone2-right.inp
./proj1 < ../test/cstone2-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token COMMENT ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token COMMENT ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0
Entering state 7
Next token is token COMMENT ()
Line 4 : syntax error : /* hello, this file is grammatically correct!  */ 
make: *** [run] Error 1
FAILED
testing  ../test/dsudaria-right.inp
int x[25][25], y[55][55], z[11][11];
int i, j, k;
i = 0;
while (i < 100) {
j = 0;
while (j < 100) {
if (!(z[i][j] == 0.0))
z[i][j] = 0.0;
k = 0;
while (k < 100) {
z[i][j] = z[i][j] + x[i][k] * y[k][j];
k = k + 1;
}
j = j + 1;
}
i = i + 1;
}

./proj1 < ../test/dsudaria-right.inp
./proj1 < ../test/dsudaria-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 11 29 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token NOT ()
Shifting token NOT ()
Entering state 34
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 35
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token EQ ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 64
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 11 29 1 18 34
Entering state 60
Reading a token: Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 97
Reducing stack by rule 22 (line 68):
   $1 = token LPAREN ()
   $2 = token NOT ()
   $3 = nterm eqparens ()
   $4 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 11 29 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8 11 29 8 11 29
Entering state 10
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 10 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 10 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 10
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 10 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 10 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 10 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 10
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 10
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 10 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 10 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 10 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 10
Entering state 28
Next token is token WHILE ()
Reducing stack by rule 10 (line 52):
   $1 = nterm if ()
   $2 = nterm block ()
-> $$ = nterm conditional ()
Stack now 0 8 11 29 8 11 29
Entering state 9
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 9 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 11 29 9 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 11 29 8 11 29 9
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token PLUS ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token MULT ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 11 29 9
Entering state 8
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 8 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 8 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 8 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29 9
Entering state 26
Reducing stack by rule 2 (line 42):
   $1 = nterm conditional ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8
Entering state 8
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 8
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 8 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 8 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 8 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 8 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 8 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 8 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 8 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 8
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 8
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 8
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 8
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8
Entering state 8
Reading a token: Now at end of input.
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0
Entering state 7
Now at end of input.
Shifting token $end ()
Entering state 24
Stack now 0 7 24
Cleanup: popping token $end ()
Cleanup: popping nterm input ()
testing  ../test/jdobler-right.inp
int a, b, c;
a = 12;
b = 11;
c = a + b * c / (3 +4);
if ( (a != b) || (a == c) )
  /*lets do some work here*/
  {
    a = 5;
    c = c * c;
  }
else
  a = b;
float b[12];
b[2] = -4;
b[a] = +5 / -6;
./proj1 < ../test/jdobler-right.inp
./proj1 < ../test/jdobler-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 47 83
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 17 33 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token DIV ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 17 33 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 47 83 47 83
Entering state 47
Next token is token DIV ()
Shifting token DIV ()
Entering state 81
Reducing stack by rule 69 (line 131):
   $1 = token DIV ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 17 33 47 83 47 83 47
Entering state 83
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 58
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 17 33 47 83 47 83 47 83 58
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 47 83 47 83 47 83 58
Entering state 95
Reading a token: Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 17 33 47 83 47 83 47 83 58 95
Entering state 122
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 17 33 47 83 47 83 47 83 58 95 122
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 47 83 47 83 47 83 58 95 122
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 47 83 47 83 47 83 58 95 122
Entering state 128
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 131
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 60 (line 121):
   $1 = token LPAREN ()
   $2 = nterm variable ()
   $3 = nterm operator ()
   $4 = nterm math ()
   $5 = token RPAREN ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 47 83 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13
Entering state 13
Reading a token: Next token is token IF ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 35
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token NE ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 1 18 35
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 1 18 35
Entering state 64
Next token is token NE ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18 35
Entering state 46
Next token is token NE ()
Shifting token NE ()
Entering state 78
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 1 18 35 46 78
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 1 18 35 46 78
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18 35 46 78
Entering state 113
Reducing stack by rule 32 (line 81):
   $1 = nterm math ()
   $2 = token NE ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 1 18 35
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 1 18
Entering state 40
Reading a token: Next token is token OR ()
Line 5 : syntax error : || 
make: *** [run] Error 1
FAILED
testing  ../test/jfoster7-right.inp
-4;
if(a<2)
{
a=a*2;
int b;
b<2; //just a boolean statement
}
else
b=2;
while(a>=2 && b==2)
{
int a;
a=2+2*2-4/8-2*5;
2-2;
}
./proj1 < ../test/jfoster7-right.inp
./proj1 < ../test/jfoster7-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token MINUS ()
Line 1 : syntax error : - 
make: *** [run] Error 1
FAILED
testing  ../test/jjudd2-right.inp
int a;
float c[10];
if(b<20)
a=b+a;
while(a==2)
a=b*5-2
./proj1 < ../test/jjudd2-right.inp
./proj1 < ../test/jjudd2-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token IF ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 1 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 1 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 1 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 1 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 1 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8
Entering state 10
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 10 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 10 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 10 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 10 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 10 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 10
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 10
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 10
Entering state 28
Next token is token WHILE ()
Reducing stack by rule 10 (line 52):
   $1 = nterm if ()
   $2 = nterm block ()
-> $$ = nterm conditional ()
Stack now 0 8
Entering state 9
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token EQ ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 9 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 9 2 18
Entering state 47
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 2 18
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 9 2 18 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 9 2 18 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 2 18 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 9 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 9 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 9
Entering state 11
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 9 11
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 9 11 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 9 11 17 33
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 9 11 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 9 11 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 9 11 17 33 47 83
Entering state 47
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 80
Reducing stack by rule 68 (line 130):
   $1 = token MINUS ()
-> $$ = nterm operator ()
Stack now 0 8 9 11 17 33 47 83 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 9 11 17 33 47 83 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 9 11 17 33 47 83 47 83
Entering state 47
Reading a token: Now at end of input.
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 11 17 33 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 9 11 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 9 11 17 33
Entering state 59
Now at end of input.
Line 7 : syntax error :  
make: *** [run] Error 1
FAILED
testing  ../test/jlail-right.inp
int x, y, z;
float a[100], b[200], c[12][12][12][12];

y = 5;
z = 10 + 2;
x = y + z;

while (x == 5)
{
	y = 3 + z;
}

while (x >= z)
	z = z + 1;

while (!(x))
{
	x = z + y - a[100];
}

y = +3;
y = -3;

if (x == 1 && y == 0)
{
	x = 3;
	y = 4;
}

if (x+1 == 3)
{
	x = -(10 - y) + (+z);
}

{a = b + c; d = a * 2;}

if (a < b) c = b; else c = a;./proj1 < ../test/jlail-right.inp
./proj1 < ../test/jlail-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 91 55 3 21 49 85 21 49 85 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 91 55 3 21 49 85 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 91 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33
Entering state 47
Reading a token: Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 13 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 13 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 13 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token EQ ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18
Entering state 47
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 2 18 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 17 33
Entering state 47
Reading a token: Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8
Entering state 8
Reading a token: Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token GE ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 2 18
Entering state 47
Next token is token GE ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 2 18
Entering state 46
Next token is token GE ()
Shifting token GE ()
Entering state 76
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 2 18 46 76
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 2 18 46 76
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 2 18 46 76
Entering state 111
Reducing stack by rule 33 (line 82):
   $1 = nterm math ()
   $2 = token GE ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 8
Entering state 11
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 11
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 11 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 11 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 8 11 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 11 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 11 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 11 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 11 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 11
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 11
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 8 11
Entering state 30
Reducing stack by rule 7 (line 48):
   $1 = nterm while ()
   $2 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 8
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token NOT ()
Shifting token NOT ()
Entering state 34
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 35
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 2 18 34 35
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 2 18 34 35
Entering state 64
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 2 18 34 35
Entering state 46
Next token is token RPAREN ()
Reducing stack by rule 37 (line 86):
   $1 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 8 8 2 18 34 35
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 8 8 2 18 34
Entering state 60
Reading a token: Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 97
Reducing stack by rule 22 (line 68):
   $1 = token LPAREN ()
   $2 = token NOT ()
   $3 = nterm eqparens ()
   $4 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 8 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 8 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 11 29 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 11 29 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 8 8 11 29 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MINUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 11 29 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 11 29 17 33 47 83
Entering state 47
Next token is token MINUS ()
Shifting token MINUS ()
Entering state 80
Reducing stack by rule 68 (line 130):
   $1 = token MINUS ()
-> $$ = nterm operator ()
Stack now 0 8 8 8 11 29 17 33 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 8 8 11 29 17 33 47 83 47 83 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 8 8 11 29 17 33 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 11 29 17 33 47 83 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 11 29 17 33 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 8 11 29 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 8 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 11 29
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 8 8 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 8 8 11 29
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 8 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8 8 8
Entering state 8
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token PLUS ()
Shifting token PLUS ()
Entering state 38
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 17 33 38
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 17 33 38
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 17 33 38
Entering state 65
Reducing stack by rule 58 (line 119):
   $1 = token PLUS ()
   $2 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 8
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 8
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 39
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 13 17 33 39
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 13 17 33 39
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 13 17 33 39
Entering state 66
Reducing stack by rule 59 (line 120):
   $1 = token MINUS ()
   $2 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 8 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 8 13
Entering state 13
Reading a token: Next token is token IF ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 8 8 8 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 8 8 8
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 8 8 8
Entering state 8
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token EQ ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 1 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 1 18
Entering state 47
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 1 18
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 8 1 18 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 1 18 46 77
Entering state 47
Reading a token: Next token is token AND ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 1 18 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 8 8 8 8 1 18
Entering state 43
Next token is token AND ()
Shifting token AND ()
Entering state 70
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token EQ ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 1 18 43 70
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 1 18 43 70
Entering state 47
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 1 18 43 70
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 8 1 18 43 70 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 1 18 43 70 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 1 18 43 70 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 8 8 8 8 1 18 43 70
Entering state 104
Next token is token RPAREN ()
Reducing stack by rule 25 (line 72):
   $1 = nterm equality ()
   $2 = token AND ()
   $3 = nterm equality ()
-> $$ = nterm and ()
Stack now 0 8 8 8 8 8 1 18
Entering state 41
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 68
Reducing stack by rule 23 (line 69):
   $1 = token LPAREN ()
   $2 = nterm and ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 8 8 8 8 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8 8 8 8 8
Entering state 10
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 27
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 10 27
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 8 10 27 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 10 27 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 10 27 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 8 8 10 27
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 8 8 10 27
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 10 27 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 8 10 27 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 10 27 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 10 27 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 8 8 10 27 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 8 8 10 27 13
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 8 8 8 8 10 27 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 8 8 8 8 10 27
Entering state 51
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 87
Reading a token: Next token is token IF ()
Reducing stack by rule 12 (line 54):
   $1 = nterm if ()
   $2 = token LBRACE ()
   $3 = nterm block ()
   $4 = token RBRACE ()
-> $$ = nterm conditional ()
Stack now 0 8 8 8 8 8
Entering state 9
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 1 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 1 18
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 8 8 8 8 9 1 18 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 8 9 1 18 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 1 18 47 83
Entering state 47
Reading a token: Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 1 18 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 1 18
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 8 9 1 18 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 1 18 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 1 18 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 8 8 8 8 9 1 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 8 8 8 8 9 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8 8 8 8 8 9
Entering state 10
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 27
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 10 27
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 39
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 58
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58
Entering state 95
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 80
Reducing stack by rule 68 (line 130):
   $1 = token MINUS ()
-> $$ = nterm operator ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58 95
Entering state 122
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58 95 122
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58 95 122
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58 95 122
Entering state 128
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 131
Reading a token: Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58 95 122 128 131
Entering state 133
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 58
Reading a token: Next token is token PLUS ()
Shifting token PLUS ()
Entering state 93
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58 95 122 128 131 133 58 93
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58 95 122 128 131 133 58 93
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58 95 122 128 131 133 58 93
Entering state 120
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 123
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 61 (line 122):
   $1 = token LPAREN ()
   $2 = token PLUS ()
   $3 = nterm math ()
   $4 = token RPAREN ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39 58 95 122 128 131 133
Entering state 135
Reducing stack by rule 63 (line 124):
   $1 = token LPAREN ()
   $2 = nterm variable ()
   $3 = nterm operator ()
   $4 = nterm math ()
   $5 = token RPAREN ()
   $6 = nterm operator ()
   $7 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 10 27 17 33 39
Entering state 66
Reducing stack by rule 59 (line 120):
   $1 = token MINUS ()
   $2 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 10 27 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 8 8 9 10 27
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 8 8 9 10 27
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 8 8 8 8 9 10 27
Entering state 51
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 87
Reading a token: Next token is token LBRACE ()
Reducing stack by rule 12 (line 54):
   $1 = nterm if ()
   $2 = token LBRACE ()
   $3 = nterm block ()
   $4 = token RBRACE ()
-> $$ = nterm conditional ()
Stack now 0 8 8 8 8 8 9
Entering state 9
Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 6
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 9 6 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 8 8 8 8 9 9 6 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 9 6 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 9 6 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 9 6 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 8 8 9 9 6
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 8 8 9 9 6
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 9 6 13 17 33
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 8 8 8 8 9 9 6 13 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 8 8 8 9 9 6 13 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 9 6 13 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 9 6 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 9 6 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 8 8 9 9 6 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 8 8 9 9 6 13
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 8 8 8 8 9 9 6 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 8 8 8 8 9 9 6
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 8 8 8 8 9 9 6
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 8 8 8 8 9 9 6
Entering state 23
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 50
Reading a token: Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 1 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 1 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 1 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 1 18 46 73
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 1 18 46 73
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 1 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 1 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8 8 8 8 8 9 9 6 23 50
Entering state 10
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 17 33
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10
Entering state 13
Reading a token: Next token is token ELSE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10
Entering state 28
Next token is token ELSE ()
Shifting token ELSE ()
Entering state 52
Reducing stack by rule 17 (line 61):
   $1 = token ELSE ()
-> $$ = nterm else ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 28
Entering state 53
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 28 53
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 28 53 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 28 53 17 33
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 28 53 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 28 53
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 28 53
Entering state 13
Reading a token: Now at end of input.
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 8 8 8 8 9 9 6 23 50 10 28 53
Entering state 89
Reducing stack by rule 11 (line 53):
   $1 = nterm if ()
   $2 = nterm block ()
   $3 = nterm else ()
   $4 = nterm block ()
-> $$ = nterm conditional ()
Stack now 0 8 8 8 8 8 9 9 6 23 50
Entering state 9
Now at end of input.
Reducing stack by rule 4 (line 44):
   $1 = nterm conditional ()
-> $$ = nterm input ()
Stack now 0 8 8 8 8 8 9 9 6 23 50
Entering state 86
Reducing stack by rule 6 (line 46):
   $1 = token LBRACE ()
   $2 = nterm input ()
   $3 = token RBRACE ()
   $4 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 8 8 8 8 9 9
Entering state 26
Reducing stack by rule 2 (line 42):
   $1 = nterm conditional ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 8 8 8 8 9
Entering state 26
Reducing stack by rule 2 (line 42):
   $1 = nterm conditional ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 8 8 8 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 8 8 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 8 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0
Entering state 7
Now at end of input.
Shifting token $end ()
Entering state 24
Stack now 0 7 24
Cleanup: popping token $end ()
Cleanup: popping nterm input ()
testing  ../test/kknight-right.inp
int i, j, k;
float x[20];

i = -43;
k = 0;

if (i >= 0) j = i + 15; else j = i;

while (k < 20) {
k = k + 1;
x[k] = 0;
}

./proj1 < ../test/kknight-right.inp
./proj1 < ../test/kknight-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 39
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 17 33 39
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 39
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33 39
Entering state 66
Reducing stack by rule 59 (line 120):
   $1 = token MINUS ()
   $2 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13
Entering state 13
Reading a token: Next token is token IF ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token GE ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 1 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 1 18
Entering state 47
Next token is token GE ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18
Entering state 46
Next token is token GE ()
Shifting token GE ()
Entering state 76
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 1 18 46 76
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 1 18 46 76
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18 46 76
Entering state 111
Reducing stack by rule 33 (line 82):
   $1 = nterm math ()
   $2 = token GE ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 1 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8
Entering state 10
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 10 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 10 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 10 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 10 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 10 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 10 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 10
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 10
Entering state 13
Reading a token: Next token is token ELSE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 10
Entering state 28
Next token is token ELSE ()
Shifting token ELSE ()
Entering state 52
Reducing stack by rule 17 (line 61):
   $1 = token ELSE ()
-> $$ = nterm else ()
Stack now 0 8 10 28
Entering state 53
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 28 53
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 28 53 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 10 28 53 17 33
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 10 28 53 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 10 28 53
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 10 28 53
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 10 28 53
Entering state 89
Reducing stack by rule 11 (line 53):
   $1 = nterm if ()
   $2 = nterm block ()
   $3 = nterm else ()
   $4 = nterm block ()
-> $$ = nterm conditional ()
Stack now 0 8
Entering state 9
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 9 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 9 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 9 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 9 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 9 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 9 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 9
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 9 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 9 11 29 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 9 11 29 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 9 11 29 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 9 11 29 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 9 11 29 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 11 29 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 9 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 9 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 9 11 29
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 9 11 29 13 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 9 11 29 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 9 11 29 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 9 11 29 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 11 29 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 9 11 29 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 9 11 29 13
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 9 11 29 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 9 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 9 11 29
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 9 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8 9
Entering state 8
Reading a token: Now at end of input.
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 9
Entering state 26
Reducing stack by rule 2 (line 42):
   $1 = nterm conditional ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0
Entering state 7
Now at end of input.
Shifting token $end ()
Entering state 24
Stack now 0 7 24
Cleanup: popping token $end ()
Cleanup: popping nterm input ()
testing  ../test/mbrown22-right.inp
int a, b[100], c[2000][10], d[a];
float g, h[a][100], i;
a[g] = (a[12]+b)-c*c/w;
b=10.0;
while(a-b>=c) 
{
   while(b<=c) int a;
}

if(!(g[100][a] == 10.0))
{
   if(i!=j)
   {
      int y;
      if(k==l) int b;
   }
}
else
{
   int x;
}
./proj1 < ../test/mbrown22-right.inp
./proj1 < ../test/mbrown22-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 13 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 58
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token PLUS ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 13 17 33 58 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58
Entering state 95
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 17 33 58 95
Entering state 122
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58 95 122
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58 95 122
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33 58 95 122
Entering state 128
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 131
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 80
Reducing stack by rule 68 (line 130):
   $1 = token MINUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 17 33 58 95 122 128 131
Entering state 133
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58 95 122 128 131 133
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58 95 122 128 131 133
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token DIV ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83
Entering state 47
Next token is token DIV ()
Shifting token DIV ()
Entering state 81
Reducing stack by rule 69 (line 131):
   $1 = token DIV ()
-> $$ = nterm operator ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33 58 95 122 128 131 133
Entering state 135
Reducing stack by rule 63 (line 124):
   $1 = token LPAREN ()
   $2 = nterm variable ()
   $3 = nterm operator ()
   $4 = nterm math ()
   $5 = token RPAREN ()
   $6 = nterm operator ()
   $7 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MINUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18
Entering state 47
Next token is token MINUS ()
Shifting token MINUS ()
Entering state 80
Reducing stack by rule 68 (line 130):
   $1 = token MINUS ()
-> $$ = nterm operator ()
Stack now 0 8 2 18 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token GE ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 47 83
Entering state 47
Next token is token GE ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 2 18
Entering state 46
Next token is token GE ()
Shifting token GE ()
Entering state 76
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18 46 76
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 46 76
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 46 76
Entering state 111
Reducing stack by rule 33 (line 82):
   $1 = nterm math ()
   $2 = token GE ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LE ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 2 18
Entering state 47
Next token is token LE ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 2 18
Entering state 46
Next token is token LE ()
Shifting token LE ()
Entering state 75
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 2 18 46 75
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 2 18 46 75
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 2 18 46 75
Entering state 110
Reducing stack by rule 34 (line 83):
   $1 = nterm math ()
   $2 = token LE ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 11 29
Entering state 11
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 8 11 29 11
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 11 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 8 11 29 11
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 11
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 11
Entering state 30
Reducing stack by rule 7 (line 48):
   $1 = nterm while ()
   $2 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8
Entering state 8
Reading a token: Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token NOT ()
Shifting token NOT ()
Entering state 34
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 35
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token EQ ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 8 1 18 34 35 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 8 1 18 34 35 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 8 1 18 34 35
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 8 1 18 34 35
Entering state 64
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 1 18 34 35
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 8 8 1 18 34 35 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 1 18 34 35 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 1 18 34 35 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 8 1 18 34 35
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 8 1 18 34
Entering state 60
Reading a token: Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 97
Reducing stack by rule 22 (line 68):
   $1 = token LPAREN ()
   $2 = token NOT ()
   $3 = nterm eqparens ()
   $4 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 8 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8 8
Entering state 10
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 27
Reading a token: Next token is token IF ()
Line 12 : syntax error : if 
make: *** [run] Error 1
FAILED
testing  ../test/mevans-right.inp
/* This is a comment */
int a, b, c, d;
float e;
a = -5;



b = 6;
	c = 12;
d = -20; // another comment
e = -2.3;
if (a >= (b * 2)) {
a = a + 5;
if ((c == d) || (((b - d)/2) < 100)) {
c = c + 10;
}
} else {
b = 0;
a = b + c;
d = a / 2;
}
./proj1 < ../test/mevans-right.inp
./proj1 < ../test/mevans-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token COMMENT ()
Line 1 : syntax error : /* This is a comment */ 
make: *** [run] Error 1
FAILED
testing  ../test/ncarlson-right.inp
int a;
int b;
int c;

a = (a * b) / (b + c) * -23244;

{
	float a[100][100], b[100], c[100][100];
	int i, j, k;
	iijeg = 0;
}

{
	i = i;
	c = a * b / c + c * a - b;
	/* Nested block example...*/
	{
		int i;
	}
}

while (a > b)
	b - c;

while (a < b && ((i <= 4)))
{
	int a;
	int b;

	if (!(a == b + 1 * (c - 1) / 2)) 
	{
		if (c == b)
		{
			c = 4 == c;
		}
	}	
	else
		c = a;
}

while ((a == b) && a < c)
	a = a + 1;./proj1 < ../test/ncarlson-right.inp
./proj1 < ../test/ncarlson-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 58
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 17 33 58
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 58
Entering state 95
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 17 33 58 95
Entering state 122
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 17 33 58 95 122
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 58 95 122
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 58 95 122
Entering state 128
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 131
Reading a token: Next token is token DIV ()
Shifting token DIV ()
Entering state 81
Reducing stack by rule 69 (line 131):
   $1 = token DIV ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 17 33 58 95 122 128 131
Entering state 133
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 58
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58
Entering state 95
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58 95
Entering state 122
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58 95 122
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58 95 122
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58 95 122
Entering state 128
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 131
Reading a token: Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58 95 122 128 131
Entering state 133
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 39
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58 95 122 128 131 133 39
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58 95 122 128 131 133 39
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58 95 122 128 131 133 39
Entering state 66
Reducing stack by rule 59 (line 120):
   $1 = token MINUS ()
   $2 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133 58 95 122 128 131 133
Entering state 135
Reducing stack by rule 63 (line 124):
   $1 = token LPAREN ()
   $2 = nterm variable ()
   $3 = nterm operator ()
   $4 = nterm math ()
   $5 = token RPAREN ()
   $6 = nterm operator ()
   $7 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33 58 95 122 128 131 133
Entering state 135
Reducing stack by rule 63 (line 124):
   $1 = token LPAREN ()
   $2 = nterm variable ()
   $3 = nterm operator ()
   $4 = nterm math ()
   $5 = token RPAREN ()
   $6 = nterm operator ()
   $7 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13
Entering state 13
Reading a token: Next token is token LBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 6
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 8 6
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 6 16 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 6 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 6 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 6 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 6 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 6 16 32 55 91 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 6 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 6 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 8 6 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 8 6 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 8 6
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 8 6
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 8 6 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 13 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 8 6 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 8 6 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 8 6 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 8 6 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 6 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 6 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 6 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 6 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 6 13 13
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 6 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 6 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 6
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 6
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 6
Entering state 23
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 50
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 6
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 23 50 6
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 23 50 6 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 23 50 6 17 33
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 6 23 50 6 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 6 23 50 6
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 6 23 50 6
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 23 50 6 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 23 50 6 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 23 50 6 13 17 33
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 6 23 50 6 13 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token DIV ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 23 50 6 13 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 23 50 6 13 17 33 47 83
Entering state 47
Next token is token DIV ()
Shifting token DIV ()
Entering state 81
Reducing stack by rule 69 (line 131):
   $1 = token DIV ()
-> $$ = nterm operator ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MINUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83 47 83
Entering state 47
Next token is token MINUS ()
Shifting token MINUS ()
Entering state 80
Reducing stack by rule 68 (line 130):
   $1 = token MINUS ()
-> $$ = nterm operator ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83 47 83 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 6 23 50 6 13 17 33 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 6 23 50 6 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 6 23 50 6 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 6 23 50 6 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 6 23 50 6 13
Entering state 13
Reading a token: Next token is token COMMENT ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 6 23 50 6 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 6 23 50 6
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 6 23 50 6
Entering state 8
Next token is token COMMENT ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 6 23 50 6
Entering state 23
Next token is token COMMENT ()
Line 16 : syntax error : /* Nested block example...*/ 
make: *** [run] Error 1
FAILED
testing  ../test/pleedom-right.inp
{
/* this is a C comment */
int a[100][10], b, c[10],d;
float x[100][10], y, z[10];
b = d;
y = -10.034;
b = -5;
b = -b;
d =--b;
d = !-b;
d = !-5;
d = -!b;
d = -!5;
{;;{};;} /* WHO WOULD DO THIS??? */

b=d=a[10][2]=10;
 
while (!a[100][1])  /* Comments in a line */
{
    if (!(a[10][2]==b))
    {
        int f;
	int g;
	9+9--10+5*13/-5;
        c[10] = 0;
        while (c[10]=0)
        {
            if ( 1+1 ) c[10]=1;
            else
            {
                int h;
		10+10;
                8+8;
            }
        }
     }
     else b = 20;
     if (3+3) a[100][1] = 1;
}
}
./proj1 < ../test/pleedom-right.inp
./proj1 < ../test/pleedom-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 6
Reading a token: Next token is token COMMENT ()
Line 2 : syntax error : /* this is a C comment */ 
make: *** [run] Error 1
FAILED
testing  ../test/right1.inp
float a[100][100], b[100][100], c[100][100];
int i, j, k;
i = 0;
while (i < 100) {
j = 0;
while (j < 100) {
if (!(c[i][j] == 0.0))
c[i][j] = 0.0;
k = 0;
while (k < 100) {
c[i][j] = c[i][j] + a[i][k] * b[k][j];
k = k + 1;
}
j = j + 1;
}
i = i + 1;
}

./proj1 < ../test/right1.inp
./proj1 < ../test/right1.inp
Starting parse
Entering state 0
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 11 29 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token NOT ()
Shifting token NOT ()
Entering state 34
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 35
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token EQ ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 64
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 11 29 1 18 34
Entering state 60
Reading a token: Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 97
Reducing stack by rule 22 (line 68):
   $1 = token LPAREN ()
   $2 = token NOT ()
   $3 = nterm eqparens ()
   $4 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 11 29 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8 11 29 8 11 29
Entering state 10
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 10 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 10 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 10
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 10 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 10 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 10 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 10
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 10
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 10 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 10 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 10 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 10
Entering state 28
Next token is token WHILE ()
Reducing stack by rule 10 (line 52):
   $1 = nterm if ()
   $2 = nterm block ()
-> $$ = nterm conditional ()
Stack now 0 8 11 29 8 11 29
Entering state 9
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 9 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 11 29 9 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 11 29 8 11 29 9
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token PLUS ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token MULT ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 11 29 9
Entering state 8
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 8 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 8 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 8 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29 9
Entering state 26
Reducing stack by rule 2 (line 42):
   $1 = nterm conditional ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8
Entering state 8
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 8
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 8 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 8 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 8 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 8 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 8 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 8 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 8 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 8
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 8
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 8
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 8
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8
Entering state 8
Reading a token: Now at end of input.
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0
Entering state 7
Now at end of input.
Shifting token $end ()
Entering state 24
Stack now 0 7 24
Cleanup: popping token $end ()
Cleanup: popping nterm input ()
testing  ../test/rmascare-right.inp
int p[9][9], r[8][8], s[7][7];
int a, b, c;
a = 6;
while (a < 20) {
b = 5;
while (b < 21) {
if (!(s[a][b] == 0.0))
s[a][b] = 0.0;
c = 4;
while (c < 22) {
s[a][b] = s[a][b] + p[a][b] * r[a][b];
c = c + 3;
}
b = b + 2;
}
a = a + 1;
}
int d, e;
e = 3;
for( d = 0; d < e; d ++)
{
 int f = 0;
 f = e + d;
}
/* This is a test for comments */

./proj1 < ../test/rmascare-right.inp
./proj1 < ../test/rmascare-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 11 29 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token NOT ()
Shifting token NOT ()
Entering state 34
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 35
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token EQ ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 64
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 1 18 34 35 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 8 11 29 1 18 34 35
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 11 29 1 18 34
Entering state 60
Reading a token: Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 97
Reducing stack by rule 22 (line 68):
   $1 = token LPAREN ()
   $2 = token NOT ()
   $3 = nterm eqparens ()
   $4 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 11 29 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8 11 29 8 11 29
Entering state 10
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 10 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 10 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 10
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 10 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 10 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 10 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 10
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 10
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 10 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 10 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 10 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 10 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 10
Entering state 28
Next token is token WHILE ()
Reducing stack by rule 10 (line 52):
   $1 = nterm if ()
   $2 = nterm block ()
-> $$ = nterm conditional ()
Stack now 0 8 11 29 8 11 29
Entering state 9
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 9 2 18 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 2 18 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 2 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 11 29 8 11 29 9 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 11 29 8 11 29 9 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8 11 29 8 11 29 9
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token PLUS ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token MULT ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 11 29 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 9 11 29 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29 9 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 11 29 9
Entering state 8
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 11 29 9 8 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 8 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 8 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 11 29 9 8 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29 9 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29 9
Entering state 26
Reducing stack by rule 2 (line 42):
   $1 = nterm conditional ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8
Entering state 8
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 8
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 8 8 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 8 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 8 8 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 8 8 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 8 8 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 8 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 8 8 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 8 8
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 8 8
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 8 8
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29 8 8
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8
Entering state 8
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 8 8
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 16 32 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 8 8 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 8 8
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 8 8
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 8 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 8 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 8 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 8 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 8 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 8 13 13
Entering state 17
Next token is token LPAREN ()
Line 20 : syntax error : ( 
make: *** [run] Error 1
FAILED
testing  ../test/ssmith14-right.inp
int a;
b = 2;
if(c == 1)
{
	/* asdf */
	i = 1;
}
while(c == 1)
{
	j = 1;
	if(c == 2)
		i = 1;
}

./proj1 < ../test/ssmith14-right.inp
./proj1 < ../test/ssmith14-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token IF ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token EQ ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 1 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 1 18
Entering state 47
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 1 18 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 1 18 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 1 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8
Entering state 10
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 27
Reading a token: Next token is token COMMENT ()
Line 5 : syntax error : /* asdf */ 
make: *** [run] Error 1
FAILED
testing  ../test/tdoss-right.inp
	1 + 2;

	{ { {} {1+4;} } {} }
	{ {} { {1-4;} {} } }

	int i, j, k;
./proj1 < ../test/tdoss-right.inp
./proj1 < ../test/tdoss-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token ICONST ()
Line 1 : syntax error : 1 
make: *** [run] Error 1
FAILED
testing  ../test/tmacmill-right.inp
float a[100][100][211], b[100], c[101][101], hamlet;
int i, j, k, a[11];
i = 0;
while ((i < 100)||(2 == 4)) {
j = 0;
while (j <= 100) {
if (!(c[i][j] == 0.0))
c[i][j] = 0.0;
k = 0;
if (k < 100) {
c[i][j] = c[i][j] + a[i][k] * b[k][j];
k = k + 1;
}
else {
j = j + 1;
}
}
i = i + 1 *3*2*k*j-2;
int q;
q = -1;
}

./proj1 < ../test/tmacmill-right.inp
./proj1 < ../test/tmacmill-right.inp
Starting parse
Entering state 0
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 3 21 49 85 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 91 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 35
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18 35
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 35
Entering state 64
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 35
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 2 18 35 46 73
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 35 46 73
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 35 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18 35
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 2 18
Entering state 40
Reading a token: Next token is token OR ()
Line 4 : syntax error : || 
make: *** [run] Error 1
testing wrong inputs:
testing  ../test/alanghar-wrong.inp
this_should_fail
14_id_starting_with_number;
int invalid[3;];
float invalid[3.5];
if(if(true))
}{
*/ /*
/* *** */*/*/./proj1 < ../test/alanghar-wrong.inp
./proj1 < ../test/alanghar-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ICONST ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0
Entering state 17
Next token is token ICONST ()
Line 2 : syntax error : 14 
make: *** [run] Error 1
testing  ../test/alynn-wrong.inp
int x, y;
x = 208
y = int
int float z;

if (x > y) {
z = 356.12;
z int != 52;
./proj1 < ../test/alynn-wrong.inp
./proj1 < ../test/alynn-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 17 33
Entering state 47
Reading a token: Next token is token ID ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 17 33
Entering state 59
Next token is token ID ()
Line 3 : syntax error : y 
make: *** [run] Error 1
testing  ../test/amoorhou-wrong.inp
/*I AM HAVING AN ISSUE CONTINUING AFTER I HAVE AN ERROR*/
/*AT THE FIRST ERROR IT PRINTS AND EXITS*/
int 2
float x;
flot a;
a [100;./proj1 < ../test/amoorhou-wrong.inp
./proj1 < ../test/amoorhou-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token COMMENT ()
Line 1 : syntax error : /*I AM HAVING AN ISSUE CONTINUING AFTER I HAVE AN ERROR*/ 
make: *** [run] Error 1
testing  ../test/bwoodroo-wrong.inp
int a;
int b

a = 5
b = 7;

a +- b

while (b = 5 {)}
./proj1 < ../test/bwoodroo-wrong.inp
./proj1 < ../test/bwoodroo-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ID ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token ID ()
Line 4 : syntax error : a 
make: *** [run] Error 1
testing  ../test/chare-wrong.inp
float x;
int a, b, c;
{a = b + c; d = a * e; ]

while(a > b) {
a = a - 2;
}
./proj1 < ../test/chare-wrong.inp
./proj1 < ../test/chare-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token LBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 6
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 6 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 6 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 6 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 6
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 6
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 13 17 33
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 6 13 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 6 13 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 6 13 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 6 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 6 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 6 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 6 13
Entering state 13
Reading a token: Next token is token RBRACKET ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 6 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 6
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 6
Entering state 8
Next token is token RBRACKET ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 6
Entering state 23
Next token is token RBRACKET ()
Line 3 : syntax error : ] 
make: *** [run] Error 1
testing  ../test/cstone2-wrong.inp
float b, c;
if { b = 2; }
int a [20];

./proj1 < ../test/cstone2-wrong.inp
./proj1 < ../test/cstone2-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token IF ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LBRACE ()
Line 2 : syntax error : { 
make: *** [run] Error 1
testing  ../test/dsudaria-wrong.inp
float 1;
int 5.5
./proj1 < ../test/dsudaria-wrong.inp
./proj1 < ../test/dsudaria-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ICONST ()
Line 1 : syntax error : 1 
make: *** [run] Error 1
testing  ../test/jdobler-wrong.inp
int this_variable12;
this_variable  = 589;
float no2_variable;
no2_variable= 2.5675;
while ( a <= 12 )
{
  int b;
  b =0;
  a = a + 1;
  no2_variable = b * a;
}
 /*my error will occur here as the comment does not end
a = b + 1;
this_variable = no2_variable / 56;
./proj1 < ../test/jdobler-wrong.inp
./proj1 < ../test/jdobler-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token FCONST ()
Shifting token FCONST ()
Entering state 37
Reducing stack by rule 56 (line 116):
   $1 = token FCONST ()
-> $$ = nterm number ()
Stack now 0 13 13 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 13 13 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LE ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18
Entering state 47
Next token is token LE ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18
Entering state 46
Next token is token LE ()
Shifting token LE ()
Entering state 75
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 2 18 46 75
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 46 75
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 46 75
Entering state 110
Reducing stack by rule 34 (line 83):
   $1 = nterm math ()
   $2 = token LE ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 8 11 29
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 8 11 29
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 8 11 29
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 13 17 33
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 13 17 33
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token PLUS ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 13 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 13 13 17 33
Entering state 47
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 13 13 17 33 47
Entering state 83
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 11 29 13 13 17 33 47 83
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 13 13 17 33 47 83
Entering state 47
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 13 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 13 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 13 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 13 13 13 17 33
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 13 13 13 17 33
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 8 11 29 13 13 13 17 33 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 13 13 13 17 33 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 11 29 13 13 13 17 33 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 11 29 13 13 13 17 33 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 8 11 29 13 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 8 11 29 13 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 8 11 29 13 13 13
Entering state 13
Reading a token: Next token is token RBRACE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29 13 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 8 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29
Entering state 8
Next token is token RBRACE ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29
Entering state 54
Next token is token RBRACE ()
Shifting token RBRACE ()
Entering state 90
Reducing stack by rule 8 (line 49):
   $1 = nterm while ()
   $2 = token LBRACE ()
   $3 = nterm input ()
   $4 = token RBRACE ()
-> $$ = nterm iteration ()
Stack now 0 8
Entering state 8
Reading a token: Next token is token DIV ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8
Entering state 25
Reducing stack by rule 1 (line 41):
   $1 = nterm iteration ()
   $2 = nterm input ()
-> $$ = nterm input ()
Stack now 0
Entering state 7
Next token is token DIV ()
Line 12 : syntax error : / 
make: *** [run] Error 1
testing  ../test/jfoster7-wrong.inp
if(a<-4)
b;
if(a<=2 && b=2) //nothing needed beyond a bad statement
./proj1 < ../test/jfoster7-wrong.inp
./proj1 < ../test/jfoster7-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 1 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 1 18
Entering state 47
Next token is token LT ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 1 18
Entering state 46
Next token is token LT ()
Shifting token LT ()
Entering state 73
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 39
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 1 18 46 73 39
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 1 18 46 73 39
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 1 18 46 73 39
Entering state 66
Reducing stack by rule 59 (line 120):
   $1 = token MINUS ()
   $2 = nterm math ()
-> $$ = nterm math ()
Stack now 0 1 18 46 73
Entering state 108
Reducing stack by rule 36 (line 85):
   $1 = nterm math ()
   $2 = token LT ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 1 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0
Entering state 10
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 10
Entering state 17
Next token is token SEMICOLON ()
Line 2 : syntax error : ; 
make: *** [run] Error 1
testing  ../test/jjudd2-wrong.inp
int int a
a = 0;
./proj1 < ../test/jjudd2-wrong.inp
./proj1 < ../test/jjudd2-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token INT ()
Line 1 : syntax error : int 
make: *** [run] Error 1
testing  ../test/jlail-wrong.inp
int x
y = asdf
corn
possible error here;./proj1 < ../test/jlail-wrong.inp
./proj1 < ../test/jlail-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ID ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token ID ()
Line 2 : syntax error : y 
make: *** [run] Error 1
testing  ../test/kknight-wrong.inp
float x[5];

x[] = 4;
./proj1 < ../test/kknight-wrong.inp
./proj1 < ../test/kknight-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token RBRACKET ()
Line 3 : syntax error : ] 
make: *** [run] Error 1
testing  ../test/mbrown22-wrong.inp
int a, b[100], c[2000][10], d[a];
float g, h[a][100], i;

a[g] = (a[12]+b)-c*c/w;

while(a=c) 
{
   while(b<=c) int a
}

if(!g[100]==h)
{
   if(i!=j))
   {
      int y;
      if(k==l) int b;
   }
}
else
{
   int x;
}
./proj1 < ../test/mbrown22-wrong.inp
./proj1 < ../test/mbrown22-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3 21 49 85
Entering state 116
Reducing stack by rule 46 (line 102):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 13
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token COMMA ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 3 21 48 84
Entering state 115
Reducing stack by rule 48 (line 104):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
   $4 = nterm arraydec ()
-> $$ = nterm arraydec ()
Stack now 0 13 16 32 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 13 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 13
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 13
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 48
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 84
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 47 (line 103):
   $1 = token LBRACKET ()
   $2 = token ID ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 13 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 13
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 58
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token PLUS ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 13 17 33 58 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58
Entering state 95
Next token is token PLUS ()
Shifting token PLUS ()
Entering state 79
Reducing stack by rule 67 (line 129):
   $1 = token PLUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 17 33 58 95
Entering state 122
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58 95 122
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58 95 122
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33 58 95 122
Entering state 128
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 131
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 80
Reducing stack by rule 68 (line 130):
   $1 = token MINUS ()
-> $$ = nterm operator ()
Stack now 0 13 13 17 33 58 95 122 128 131
Entering state 133
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token MULT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58 95 122 128 131 133
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58 95 122 128 131 133
Entering state 47
Next token is token MULT ()
Shifting token MULT ()
Entering state 82
Reducing stack by rule 70 (line 132):
   $1 = token MULT ()
-> $$ = nterm operator ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token DIV ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83
Entering state 47
Next token is token DIV ()
Shifting token DIV ()
Entering state 81
Reducing stack by rule 69 (line 131):
   $1 = token DIV ()
-> $$ = nterm operator ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83 47
Entering state 83
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83 47 83
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83 47 83
Entering state 47
Next token is token SEMICOLON ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33 58 95 122 128 131 133 47 83
Entering state 114
Reducing stack by rule 57 (line 118):
   $1 = nterm variable ()
   $2 = nterm operator ()
   $3 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33 58 95 122 128 131 133
Entering state 135
Reducing stack by rule 63 (line 124):
   $1 = token LPAREN ()
   $2 = nterm variable ()
   $3 = nterm operator ()
   $4 = nterm math ()
   $5 = token RPAREN ()
   $6 = nterm operator ()
   $7 = nterm math ()
-> $$ = nterm math ()
Stack now 0 13 13 17 33
Entering state 59
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 96
Reducing stack by rule 44 (line 99):
   $1 = nterm id ()
   $2 = token ASSIGN ()
   $3 = nterm math ()
   $4 = token SEMICOLON ()
-> $$ = nterm assign ()
Stack now 0 13 13
Entering state 15
Reducing stack by rule 41 (line 94):
   $1 = nterm assign ()
-> $$ = nterm statement ()
Stack now 0 13 13
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 13 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0 13
Entering state 31
Reducing stack by rule 38 (line 90):
   $1 = nterm statement ()
   $2 = nterm block ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18
Entering state 47
Next token is token ASSIGN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18
Entering state 46
Next token is token ASSIGN ()
Reducing stack by rule 37 (line 86):
   $1 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18
Entering state 43
Next token is token ASSIGN ()
Line 6 : syntax error : = 
make: *** [run] Error 1
testing  ../test/mevans-wrong.inp
int arr[3];
arr[0];
arr[1];
arr[2];
float x = 0.33;
int y = 0;
/* comment */
if (x <= 0.25) {
y = y + 1;
} if (arr[0] > -(y))) {
// do nothing
}
} else {
while (x > 0.2.5) {
// should not reach the error above
x =; // or this one
}
}
./proj1 < ../test/mevans-wrong.inp
./proj1 < ../test/mevans-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 13 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 13
Entering state 17
Next token is token SEMICOLON ()
Line 2 : syntax error : ; 
make: *** [run] Error 1
testing  ../test/pchurch2-wrong.inp
int a, b, c
float x y, z;
x = 21.;
if (x <== 10)
if (x >= 20);
if (xyz! != 30)
if (x ==== 40)
counter = 0
while ((counter < 10) {
	int value;]
	value == 1;
	!value = value + counter;
	counter = counter + 1 -;
	if (value != 20)]
	if (value == )
}
./proj1 < ../test/pchurch2-wrong.inp
./proj1 < ../test/pchurch2-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token FLOAT ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token FLOAT ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token FLOAT ()
Line 2 : syntax error : float 
make: *** [run] Error 1
testing  ../test/pleedom-wrong.inp
int a,b,c[10];
if (a == 0) int f;
if (1=1) {
9+9;
}
./proj1 < ../test/pleedom-wrong.inp
./proj1 < ../test/pleedom-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token LBRACKET ()
Shifting token LBRACKET ()
Entering state 21
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 49
Reading a token: Next token is token RBRACKET ()
Shifting token RBRACKET ()
Entering state 85
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 45 (line 101):
   $1 = token LBRACKET ()
   $2 = token ICONST ()
   $3 = token RBRACKET ()
-> $$ = nterm arraydec ()
Stack now 0 16 32 55 91 55 3
Entering state 22
Reducing stack by rule 54 (line 113):
   $1 = token ID ()
   $2 = nterm arraydec ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token IF ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token EQ ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 1 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 1 18
Entering state 47
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 1 18 46 77
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 1 18 46 77
Entering state 47
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 1 18 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 1 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 1
Entering state 19
Reducing stack by rule 16 (line 59):
   $1 = token IF ()
   $2 = nterm eqparens ()
-> $$ = nterm if ()
Stack now 0 8
Entering state 10
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0 8 10
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 10 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 8 10
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 8 10
Entering state 13
Reading a token: Next token is token IF ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 10
Entering state 28
Next token is token IF ()
Reducing stack by rule 10 (line 52):
   $1 = nterm if ()
   $2 = nterm block ()
-> $$ = nterm conditional ()
Stack now 0 8
Entering state 9
Next token is token IF ()
Shifting token IF ()
Entering state 1
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ICONST ()
Shifting token ICONST ()
Entering state 36
Reducing stack by rule 55 (line 115):
   $1 = token ICONST ()
-> $$ = nterm number ()
Stack now 0 8 9 1 18
Entering state 45
Reducing stack by rule 72 (line 135):
   $1 = nterm number ()
-> $$ = nterm variable ()
Stack now 0 8 9 1 18
Entering state 47
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 9 1 18
Entering state 46
Next token is token ASSIGN ()
Reducing stack by rule 37 (line 86):
   $1 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 9 1 18
Entering state 43
Next token is token ASSIGN ()
Line 3 : syntax error : = 
make: *** [run] Error 1
testing  ../test/rmascare-wrong.inp
char 9;
float s;
string k = 0;
while (x ==p)
*/comment*/
int 2 
printf(""+int);
do(x){}while(u);
./proj1 < ../test/rmascare-wrong.inp
./proj1 < ../test/rmascare-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ICONST ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0
Entering state 17
Next token is token ICONST ()
Line 1 : syntax error : 9 
make: *** [run] Error 1
testing  ../test/ssmith14-wrong.inp
int a = [5];
for(/* */)
{
}
int a[5.1];
while
{
}
if
{
}
int a;
else
{
}

./proj1 < ../test/ssmith14-wrong.inp
./proj1 < ../test/ssmith14-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token ASSIGN ()
Line 1 : syntax error : = 
make: *** [run] Error 1
testing  ../test/tdoss-wrong.inp
x = float;
./proj1 < ../test/tdoss-wrong.inp
./proj1 < ../test/tdoss-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token ASSIGN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0
Entering state 17
Next token is token ASSIGN ()
Shifting token ASSIGN ()
Entering state 33
Reading a token: Next token is token FLOAT ()
Line 1 : syntax error : float 
make: *** [run] Error 1
testing  ../test/tmacmill-wrong.inp
int j, f, d;

while(d==f) {
float ext;
5 = ext;


./proj1 < ../test/tmacmill-wrong.inp
./proj1 < ../test/tmacmill-wrong.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16
Entering state 32
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token COMMA ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55
Entering state 91
Next token is token COMMA ()
Shifting token COMMA ()
Entering state 55
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 16 32 55 91 55
Entering state 91
Next token is token SEMICOLON ()
Reducing stack by rule 49 (line 106):
   $1 = token COMMA ()
   $2 = nterm id ()
-> $$ = nterm multidec ()
Stack now 0 16 32 55 91
Entering state 119
Reducing stack by rule 50 (line 107):
   $1 = token COMMA ()
   $2 = nterm id ()
   $3 = nterm multidec ()
-> $$ = nterm multidec ()
Stack now 0 16 32
Entering state 57
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 92
Reducing stack by rule 43 (line 97):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = nterm multidec ()
   $4 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0
Entering state 13
Reading a token: Next token is token WHILE ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0
Entering state 8
Next token is token WHILE ()
Shifting token WHILE ()
Entering state 2
Reading a token: Next token is token LPAREN ()
Shifting token LPAREN ()
Entering state 18
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token EQ ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18
Entering state 47
Next token is token EQ ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18
Entering state 46
Next token is token EQ ()
Shifting token EQ ()
Entering state 77
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token RPAREN ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 2 18 46 77
Entering state 44
Reducing stack by rule 71 (line 134):
   $1 = nterm id ()
-> $$ = nterm variable ()
Stack now 0 8 2 18 46 77
Entering state 47
Next token is token RPAREN ()
Reducing stack by rule 66 (line 127):
   $1 = nterm variable ()
-> $$ = nterm math ()
Stack now 0 8 2 18 46 77
Entering state 112
Reducing stack by rule 31 (line 80):
   $1 = nterm math ()
   $2 = token EQ ()
   $3 = nterm math ()
-> $$ = nterm equality ()
Stack now 0 8 2 18
Entering state 43
Next token is token RPAREN ()
Shifting token RPAREN ()
Entering state 72
Reducing stack by rule 19 (line 65):
   $1 = token LPAREN ()
   $2 = nterm equality ()
   $3 = token RPAREN ()
-> $$ = nterm eqparens ()
Stack now 0 8 2
Entering state 20
Reducing stack by rule 18 (line 63):
   $1 = token WHILE ()
   $2 = nterm eqparens ()
-> $$ = nterm while ()
Stack now 0 8
Entering state 11
Reading a token: Next token is token LBRACE ()
Shifting token LBRACE ()
Entering state 29
Reading a token: Next token is token FLOAT ()
Shifting token FLOAT ()
Entering state 5
Reducing stack by rule 52 (line 110):
   $1 = token FLOAT ()
-> $$ = nterm type ()
Stack now 0 8 11 29
Entering state 16
Reading a token: Next token is token ID ()
Shifting token ID ()
Entering state 3
Reading a token: Next token is token SEMICOLON ()
Reducing stack by rule 53 (line 112):
   $1 = token ID ()
-> $$ = nterm id ()
Stack now 0 8 11 29 16
Entering state 32
Next token is token SEMICOLON ()
Shifting token SEMICOLON ()
Entering state 56
Reducing stack by rule 42 (line 96):
   $1 = nterm type ()
   $2 = nterm id ()
   $3 = token SEMICOLON ()
-> $$ = nterm declaration ()
Stack now 0 8 11 29
Entering state 14
Reducing stack by rule 40 (line 93):
   $1 = nterm declaration ()
-> $$ = nterm statement ()
Stack now 0 8 11 29
Entering state 13
Reading a token: Next token is token ICONST ()
Reducing stack by rule 39 (line 91):
   $1 = nterm statement ()
-> $$ = nterm block ()
Stack now 0 8 11 29
Entering state 12
Reducing stack by rule 9 (line 50):
   $1 = nterm block ()
-> $$ = nterm iteration ()
Stack now 0 8 11 29
Entering state 8
Next token is token ICONST ()
Reducing stack by rule 3 (line 43):
   $1 = nterm iteration ()
-> $$ = nterm input ()
Stack now 0 8 11 29
Entering state 54
Next token is token ICONST ()
Line 5 : syntax error : 5 
make: *** [run] Error 1
testing  ../test/wrong1.inp
int 2
float x;
./proj1 < ../test/wrong1.inp
./proj1 < ../test/wrong1.inp
Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 4
Reducing stack by rule 51 (line 109):
   $1 = token INT ()
-> $$ = nterm type ()
Stack now 0
Entering state 16
Reading a token: Next token is token ICONST ()
Line 1 : syntax error : 2 
make: *** [run] Error 1
